// NOTE: multiSchema is only needed because the database has a foreign key
// constraint from public.profiles to auth.users (Supabase's auth schema).
// Once you fully integrate Supabase auth into this schema OR remove that constraint,
// you can remove the multiSchema preview feature and all @@schema("public") annotations.

generator client {
  provider        = "prisma-client-js"
  previewFeatures = ["multiSchema", "postgresqlExtensions"]
}

datasource db {
  provider   = "postgresql"
  schemas    = ["public", "auth"]
  extensions = [vector]
}

/**
 * PROJECT: The primary organizational unit.
 * All data records, ingestion jobs, and guidelines are scoped to a project.
 */
model Project {
  id           String        @id @default(cuid())
  name         String        @unique
  ownerId      String?       @map("ownerId") @db.Uuid
  owner        Profile?      @relation(fields: [ownerId], references: [id])
  records      DataRecord[]
  ingestJobs   IngestJob[]
  analyticsJobs AnalyticsJob[]

  // AI-generated summary reports (cached for dashboard display)
  lastTaskAnalysis String?       @map("lastTaskAnalysis") @db.Text
  lastFeedbackAnalysis String?   @map("lastFeedbackAnalysis") @db.Text

  // Grounding Data: Guidelines PDF stored as a base64 string for RAG analysis
  guidelines   String?       @db.Text
  guidelinesFileName String? @map("guidelinesFileName")

  // Rater management relations
  raterGroups       RaterGroup[]
  assignmentBatches AssignmentBatch[]
  llmEvaluationJobs LLMEvaluationJob[]

  createdAt    DateTime      @default(now()) @map("createdAt")
  updatedAt    DateTime      @updatedAt @map("updatedAt")

  @@map("projects")
  @@schema("public")
}

enum UserRole {
  PENDING
  USER
  MANAGER
  ADMIN

  @@schema("public")
}

/**
 * PROFILE: Application-specific user data.
 * The id field must match the Supabase auth.users(id).
 */
model Profile {
  id        String   @id @db.Uuid
  email     String   @unique
  role      UserRole @default(PENDING)
  mustResetPassword Boolean @default(false) @map("mustResetPassword")
  projects  Project[]

  // Rater management relations
  raterGroupMemberships RaterGroupMember[]
  assignedBatches       AssignmentBatch[]   @relation("AssignedBatches")
  createdBatches        AssignmentBatch[]   @relation("CreatedBatches")
  assignedRecords       AssignmentRecord[]  @relation("AssignedRecords")

  createdAt DateTime @default(now()) @map("createdAt")
  updatedAt DateTime @updatedAt @map("updatedAt")

  @@map("profiles")
  @@schema("public")
}

model AnalyticsJob {
  id            String      @id @default(cuid())
  projectId     String      @map("projectId")
  project       Project     @relation(fields: [projectId], references: [id], onDelete: Cascade)
  status        String      @default("PENDING")
  totalRecords  Int         @default(0) @map("totalRecords")
  processedCount Int         @default(0) @map("processedCount")
  error         String?     @db.Text
  createdAt     DateTime    @default(now()) @map("createdAt")
  updatedAt     DateTime    @updatedAt @map("updatedAt")

  @@map("analytics_jobs")
  @@schema("public")
}

enum RecordType {
  TASK        // Individual prompt/request
  FEEDBACK    // Human or AI evaluation of a task

  @@schema("public")
}

enum RecordCategory {
  TOP_10      // High quality/aligned
  BOTTOM_10   // Low quality/unaligned

  @@schema("public")
}

/**
 * DATA RECORD: The core data unit.
 * Contains the raw text content, original JSON metadata, and vector embeddings.
 */
model DataRecord {
  id            String         @id @default(cuid())
  projectId     String         @map("projectId")
  project       Project        @relation(fields: [projectId], references: [id], onDelete: Cascade)
  type          RecordType
  category      RecordCategory?
  source        String         // Tracking field, e.g., "csv:filename.csv" or "api:endpoint"
  content       String         @db.Text
  metadata      Json?          // Stores all original fields from the source file
  embedding     Unsupported("vector")? // pgvector variable-length - supports any embedding model dimension
  hasBeenReviewed Boolean      @default(false) // Whether a human rater has reviewed this record
  isCategoryCorrect Boolean?    // Rater's agreement: true if they agree with TOP_10/BOTTOM_10 classification
  reviewedBy    String?        // TODO: Update to authenticated user once auth is implemented

  // AI-generated comparison against the project guidelines
  alignmentAnalysis String?    @map("alignmentAnalysis") @db.Text

  // User tracking fields from ingestion
  createdById     String?        @map("createdById")
  createdByName   String?        @map("createdByName")
  createdByEmail  String?        @map("createdByEmail")

  ingestJobId   String?        @map("ingestJobId")

  likertScores  LikertScore[]

  // Assignment management relation
  assignments   AssignmentRecord[]

  createdAt     DateTime       @default(now()) @map("createdAt")
  updatedAt     DateTime       @updatedAt @map("updatedAt")

  @@map("data_records")
  @@schema("public")
}

/**
 * INGEST JOB: Background process tracker.
 * Used to manage long-running CSV uploads and API syncs.
 * Allows the UI to poll for real-time progress bars.
 */
model IngestJob {
  id            String      @id @default(cuid())
  projectId     String      @map("projectId")
  project       Project     @relation(fields: [projectId], references: [id], onDelete: Cascade)
  type          RecordType
  status        String      @default("PENDING") // Status Lifecycle: PENDING -> PROCESSING -> COMPLETED or FAILED
  totalRecords  Int         @default(0) @map("totalRecords")
  savedCount    Int         @default(0) @map("savedCount")
  skippedCount  Int         @default(0) @map("skippedCount")
  skippedDetails Json?      @map("skippedDetails")
  error         String?     @db.Text
  createdAt     DateTime    @default(now()) @map("createdAt")
  updatedAt     DateTime    @updatedAt @map("updatedAt")

  @@map("ingest_jobs")
  @@schema("public")
}

model SystemSetting {
  key         String   @id
  value       String
  description String?
  updatedAt   DateTime @updatedAt @map("updatedAt")

  @@map("system_settings")
  @@schema("public")
}

/**
 * BONUS WINDOW: Tracks time-based performance windows for all users.
 * Managers configure windows to measure collective record creation against targets.
 * Supports optional second tier targets for enhanced bonuses.
 */
model BonusWindow {
  id                      String   @id @default(dbgenerated("gen_random_uuid()")) @db.Uuid
  name                    String   @default("Bonus Window")
  startTime               DateTime @map("start_time") @db.Timestamptz
  endTime                 DateTime @map("end_time") @db.Timestamptz
  targetTaskCount         Int      @default(0) @map("target_task_count")
  targetFeedbackCount     Int      @default(0) @map("target_feedback_count")
  targetTaskCountTier2    Int      @default(0) @map("target_task_count_tier2")
  targetFeedbackCountTier2 Int     @default(0) @map("target_feedback_count_tier2")
  createdBy               String   @map("created_by") @db.Uuid
  createdAt               DateTime @default(now()) @map("created_at") @db.Timestamptz
  updatedAt               DateTime @updatedAt @map("updated_at") @db.Timestamptz

  @@map("bonus_windows")
  @@schema("public")
}

/**
 * LIKERT SCORE: User or LLM ratings for prompts on Realism and Quality scales (1-7).
 * Each user can rate a prompt only once.
 * For LLM evaluations, userId is the reserved LLM UUID (00000000-0000-0000-0000-000000000000)
 * and llmModel contains the model name (e.g., "gpt-4", "claude-3").
 */
model LikertScore {
  id              String      @id @default(cuid())
  recordId        String      @map("recordId")
  record          DataRecord  @relation(fields: [recordId], references: [id], onDelete: Cascade)
  userId          String      @map("userId")
  realismScore    Int         @map("realismScore") // 1-7 scale
  qualityScore    Int         @map("qualityScore") // 1-7 scale
  llmModel        String?     @map("llmModel") // Name of LLM if this is an LLM evaluation
  createdAt       DateTime    @default(now()) @map("createdAt")
  updatedAt       DateTime    @updatedAt @map("updatedAt")

  @@index([recordId])
  @@index([userId])
  @@index([llmModel])
  @@map("likert_scores")
  @@schema("public")
}

/**
 * AUDIT LOG: Tracks user actions and administrative operations.
 * Logs all major actions throughout the application for security and compliance.
 */
model AuditLog {
  id          String    @id
  action      String
  entityType  String    @map("entity_type")
  entityId    String?   @map("entity_id")
  projectId   String?   @map("project_id")
  userId      String    @map("user_id") @db.Uuid
  userEmail   String    @map("user_email")
  metadata    Json?
  createdAt   DateTime  @default(now()) @map("created_at") @db.Timestamptz

  @@index([userId, createdAt(sort: Desc)])
  @@index([entityType, entityId])
  @@index([action, createdAt(sort: Desc)])
  @@index([projectId])
  @@index([createdAt(sort: Desc)])
  @@map("audit_logs")
  @@schema("public")
}

// ============================================
// ENUMS FOR RATING SYSTEM
// ============================================

enum JobStatus {
  PENDING
  PROCESSING
  COMPLETED
  FAILED
  CANCELLED

  @@schema("public")
}

enum AssignmentStatus {
  PENDING      // Created but not started
  IN_PROGRESS  // At least one record being rated
  COMPLETED    // All records rated
  CANCELLED

  @@schema("public")
}

enum RecordAssignmentStatus {
  PENDING
  IN_PROGRESS
  COMPLETED
  SKIPPED

  @@schema("public")
}

// ============================================
// LLM MODEL CONFIGURATION (OpenRouter)
// ============================================

/**
 * LLM MODEL CONFIG: Configures OpenRouter models for bulk evaluation.
 * Tracks usage statistics and costs per model.
 */
model LLMModelConfig {
  id              String   @id @default(cuid())
  name            String   // Display name (e.g., "GPT-4o")
  modelId         String   @unique @map("model_id") // OpenRouter ID (e.g., "openai/gpt-4o")
  isActive        Boolean  @default(true) @map("is_active")
  priority        Int      @default(0) // Order for batch processing (lower = higher priority)

  // Custom system prompt for this model (overrides default prompt)
  systemPrompt    String?  @db.Text @map("system_prompt")

  // Cost tracking (per 1k tokens)
  inputCostPer1k  Float?   @map("input_cost_per_1k")
  outputCostPer1k Float?   @map("output_cost_per_1k")

  // Usage statistics (updated after each evaluation)
  totalTokensUsed Int      @default(0) @map("total_tokens_used")
  totalCost       Float    @default(0) @map("total_cost")
  totalRatings    Int      @default(0) @map("total_ratings")

  createdAt       DateTime @default(now()) @map("created_at")
  updatedAt       DateTime @updatedAt @map("updated_at")

  // Relations
  evaluationJobs  LLMEvaluationJob[]

  @@map("llm_model_configs")
  @@schema("public")
}

/**
 * LLM EVALUATION JOB: Tracks bulk LLM evaluation progress.
 * One job per model per project for batch rating operations.
 */
model LLMEvaluationJob {
  id              String    @id @default(cuid())
  projectId       String    @map("project_id")
  modelConfigId   String    @map("model_config_id")

  status          JobStatus @default(PENDING)
  totalRecords    Int       @default(0) @map("total_records")
  processedCount  Int       @default(0) @map("processed_count")
  errorCount      Int       @default(0) @map("error_count")

  // Cost tracking for this job
  tokensUsed      Int       @default(0) @map("tokens_used")
  cost            Float     @default(0)

  error           String?   @db.Text
  startedAt       DateTime? @map("started_at")
  completedAt     DateTime? @map("completed_at")
  createdAt       DateTime  @default(now()) @map("created_at")
  updatedAt       DateTime  @updatedAt @map("updated_at")

  // Relations
  project         Project        @relation(fields: [projectId], references: [id], onDelete: Cascade)
  modelConfig     LLMModelConfig @relation(fields: [modelConfigId], references: [id], onDelete: Cascade)

  @@index([projectId])
  @@index([modelConfigId])
  @@index([status])
  @@map("llm_evaluation_jobs")
  @@schema("public")
}

// ============================================
// RATER MANAGEMENT
// ============================================

/**
 * RATER GROUP: Organizes human raters into teams.
 * Groups can be assigned batches of records to rate.
 */
model RaterGroup {
  id          String   @id @default(cuid())
  name        String
  description String?  @db.Text
  projectId   String   @map("project_id")

  createdAt   DateTime @default(now()) @map("created_at")
  updatedAt   DateTime @updatedAt @map("updated_at")

  // Relations
  project     Project            @relation(fields: [projectId], references: [id], onDelete: Cascade)
  members     RaterGroupMember[]
  assignments AssignmentBatch[]

  @@unique([projectId, name])
  @@index([projectId])
  @@map("rater_groups")
  @@schema("public")
}

/**
 * RATER GROUP MEMBER: Links users to rater groups.
 */
model RaterGroupMember {
  id           String   @id @default(cuid())
  raterGroupId String   @map("rater_group_id")
  userId       String   @map("user_id") @db.Uuid

  joinedAt     DateTime @default(now()) @map("joined_at")

  // Relations
  raterGroup   RaterGroup @relation(fields: [raterGroupId], references: [id], onDelete: Cascade)
  user         Profile    @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@unique([raterGroupId, userId])
  @@index([userId])
  @@map("rater_group_members")
  @@schema("public")
}

// ============================================
// ASSIGNMENT MANAGEMENT
// ============================================

/**
 * ASSIGNMENT BATCH: A group of records assigned for rating.
 * Can be assigned to a rater group OR an individual user.
 */
model AssignmentBatch {
  id               String           @id @default(cuid())
  name             String
  description      String?          @db.Text
  projectId        String           @map("project_id")

  // Assignment target (either group OR individual, not both)
  raterGroupId     String?          @map("rater_group_id")
  assignedToUserId String?          @map("assigned_to_user_id") @db.Uuid

  // Batch criteria (how records were selected)
  criteria         Json?            // { category?: "TOP_10"|"BOTTOM_10", type?: "TASK"|"FEEDBACK", ... }

  // Status tracking
  status           AssignmentStatus @default(PENDING)
  totalRecords     Int              @default(0) @map("total_records")
  completedCount   Int              @default(0) @map("completed_count")

  dueDate          DateTime?        @map("due_date")
  createdAt        DateTime         @default(now()) @map("created_at")
  updatedAt        DateTime         @updatedAt @map("updated_at")
  createdById      String           @map("created_by_id") @db.Uuid

  // Relations
  project          Project          @relation(fields: [projectId], references: [id], onDelete: Cascade)
  raterGroup       RaterGroup?      @relation(fields: [raterGroupId], references: [id], onDelete: SetNull)
  assignedToUser   Profile?         @relation("AssignedBatches", fields: [assignedToUserId], references: [id], onDelete: SetNull)
  createdBy        Profile          @relation("CreatedBatches", fields: [createdById], references: [id])
  records          AssignmentRecord[]

  @@index([projectId])
  @@index([raterGroupId])
  @@index([assignedToUserId])
  @@index([status])
  @@map("assignment_batches")
  @@schema("public")
}

/**
 * ASSIGNMENT RECORD: Links individual records to assignment batches.
 * Tracks completion status per record within a batch.
 */
model AssignmentRecord {
  id                String                 @id @default(cuid())
  assignmentBatchId String                 @map("assignment_batch_id")
  recordId          String                 @map("record_id")

  // Individual assignment within batch (for distributing within a group)
  assignedToUserId  String?                @map("assigned_to_user_id") @db.Uuid

  status            RecordAssignmentStatus @default(PENDING)
  completedAt       DateTime?              @map("completed_at")

  createdAt         DateTime               @default(now()) @map("created_at")

  // Relations
  assignmentBatch   AssignmentBatch        @relation(fields: [assignmentBatchId], references: [id], onDelete: Cascade)
  record            DataRecord             @relation(fields: [recordId], references: [id], onDelete: Cascade)
  assignedToUser    Profile?               @relation("AssignedRecords", fields: [assignedToUserId], references: [id], onDelete: SetNull)

  @@unique([assignmentBatchId, recordId])
  @@index([recordId])
  @@index([assignedToUserId])
  @@index([status])
  @@map("assignment_records")
  @@schema("public")
}
