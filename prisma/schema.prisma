// NOTE: multiSchema is only needed because the database has a foreign key
// constraint from public.profiles to auth.users (Supabase's auth schema).
// Once you fully integrate Supabase auth into this schema OR remove that constraint,
// you can remove the multiSchema preview feature and all @@schema("public") annotations.

generator client {
  provider        = "prisma-client-js"
  previewFeatures = ["multiSchema", "postgresqlExtensions"]
}

datasource db {
  provider   = "postgresql"
  schemas    = ["public", "auth"]
  extensions = [vector]
}

/**
 * PROJECT: The primary organizational unit.
 * All data records, ingestion jobs, and guidelines are scoped to a project.
 */
model Project {
  id           String        @id @default(cuid())
  name         String        @unique
  ownerId      String?       @map("ownerId") @db.Uuid
  owner        Profile?      @relation(fields: [ownerId], references: [id])
  records      DataRecord[]
  ingestJobs   IngestJob[]
  analyticsJobs AnalyticsJob[]

  // AI-generated summary reports (cached for dashboard display)
  lastTaskAnalysis String?       @map("lastTaskAnalysis") @db.Text
  lastFeedbackAnalysis String?   @map("lastFeedbackAnalysis") @db.Text

  // Grounding Data: Guidelines PDF stored as a base64 string for RAG analysis
  guidelines   String?       @db.Text
  guidelinesFileName String? @map("guidelinesFileName")

  createdAt    DateTime      @default(now()) @map("createdAt")
  updatedAt    DateTime      @updatedAt @map("updatedAt")

  @@map("projects")
  @@schema("public")
}

enum UserRole {
  PENDING
  USER
  MANAGER
  ADMIN

  @@schema("public")
}

/**
 * PROFILE: Application-specific user data.
 * The id field must match the Supabase auth.users(id).
 */
model Profile {
  id        String   @id @db.Uuid
  email     String   @unique
  role      UserRole @default(PENDING)
  mustResetPassword Boolean @default(false) @map("mustResetPassword")
  projects  Project[]

  createdAt DateTime @default(now()) @map("createdAt")
  updatedAt DateTime @updatedAt @map("updatedAt")

  @@map("profiles")
  @@schema("public")
}

model AnalyticsJob {
  id            String      @id @default(cuid())
  projectId     String      @map("projectId")
  project       Project     @relation(fields: [projectId], references: [id], onDelete: Cascade)
  status        String      @default("PENDING")
  totalRecords  Int         @default(0) @map("totalRecords")
  processedCount Int         @default(0) @map("processedCount")
  error         String?     @db.Text
  createdAt     DateTime    @default(now()) @map("createdAt")
  updatedAt     DateTime    @updatedAt @map("updatedAt")

  @@map("analytics_jobs")
  @@schema("public")
}

enum RecordType {
  TASK        // Individual prompt/request
  FEEDBACK    // Human or AI evaluation of a task

  @@schema("public")
}

enum RecordCategory {
  TOP_10      // High quality/aligned
  BOTTOM_10   // Low quality/unaligned

  @@schema("public")
}

/**
 * DATA RECORD: The core data unit.
 * Contains the raw text content, original JSON metadata, and vector embeddings.
 */
model DataRecord {
  id            String         @id @default(cuid())
  projectId     String         @map("projectId")
  project       Project        @relation(fields: [projectId], references: [id], onDelete: Cascade)
  type          RecordType
  category      RecordCategory?
  source        String         // Tracking field, e.g., "csv:filename.csv" or "api:endpoint"
  content       String         @db.Text
  metadata      Json?          // Stores all original fields from the source file
  embedding     Unsupported("vector")? // pgvector variable-length - supports any embedding model dimension
  hasBeenReviewed Boolean      @default(false) // Whether a human rater has reviewed this record
  isCategoryCorrect Boolean?    // Rater's agreement: true if they agree with TOP_10/BOTTOM_10 classification
  reviewedBy    String?        // TODO: Update to authenticated user once auth is implemented

  // AI-generated comparison against the project guidelines
  alignmentAnalysis String?    @map("alignmentAnalysis") @db.Text

  // User tracking fields from ingestion
  createdById     String?        @map("createdById")
  createdByName   String?        @map("createdByName")
  createdByEmail  String?        @map("createdByEmail")

  ingestJobId   String?        @map("ingestJobId")

  likertScores  LikertScore[]

  createdAt     DateTime       @default(now()) @map("createdAt")
  updatedAt     DateTime       @updatedAt @map("updatedAt")

  @@map("data_records")
  @@schema("public")
}

/**
 * INGEST JOB: Background process tracker.
 * Used to manage long-running CSV uploads and API syncs.
 * Allows the UI to poll for real-time progress bars.
 */
model IngestJob {
  id            String      @id @default(cuid())
  projectId     String      @map("projectId")
  project       Project     @relation(fields: [projectId], references: [id], onDelete: Cascade)
  type          RecordType
  status        String      @default("PENDING") // Status Lifecycle: PENDING -> PROCESSING -> COMPLETED or FAILED
  totalRecords  Int         @default(0) @map("totalRecords")
  savedCount    Int         @default(0) @map("savedCount")
  skippedCount  Int         @default(0) @map("skippedCount")
  skippedDetails Json?      @map("skippedDetails")
  error         String?     @db.Text
  createdAt     DateTime    @default(now()) @map("createdAt")
  updatedAt     DateTime    @updatedAt @map("updatedAt")

  @@map("ingest_jobs")
  @@schema("public")
}

model SystemSetting {
  key         String   @id
  value       String
  description String?
  updatedAt   DateTime @updatedAt @map("updatedAt")

  @@map("system_settings")
  @@schema("public")
}

/**
 * BONUS WINDOW: Tracks time-based performance windows for all users.
 * Managers configure windows to measure collective record creation against targets.
 * Supports optional second tier targets for enhanced bonuses.
 */
model BonusWindow {
  id                      String   @id @default(dbgenerated("gen_random_uuid()")) @db.Uuid
  name                    String   @default("Bonus Window")
  startTime               DateTime @map("start_time") @db.Timestamptz
  endTime                 DateTime @map("end_time") @db.Timestamptz
  targetTaskCount         Int      @default(0) @map("target_task_count")
  targetFeedbackCount     Int      @default(0) @map("target_feedback_count")
  targetTaskCountTier2    Int      @default(0) @map("target_task_count_tier2")
  targetFeedbackCountTier2 Int     @default(0) @map("target_feedback_count_tier2")
  createdBy               String   @map("created_by") @db.Uuid
  createdAt               DateTime @default(now()) @map("created_at") @db.Timestamptz
  updatedAt               DateTime @updatedAt @map("updated_at") @db.Timestamptz

  @@map("bonus_windows")
  @@schema("public")
}

/**
 * LIKERT SCORE: User or LLM ratings for prompts on Realism and Quality scales (1-7).
 * Each user can rate a prompt only once.
 * For LLM evaluations, userId is the reserved LLM UUID (00000000-0000-0000-0000-000000000000)
 * and llmModel contains the model name (e.g., "gpt-4", "claude-3").
 */
model LikertScore {
  id              String      @id @default(cuid())
  recordId        String      @map("recordId")
  record          DataRecord  @relation(fields: [recordId], references: [id], onDelete: Cascade)
  userId          String      @map("userId")
  realismScore    Int         @map("realismScore") // 1-7 scale
  qualityScore    Int         @map("qualityScore") // 1-7 scale
  llmModel        String?     @map("llmModel") // Name of LLM if this is an LLM evaluation
  createdAt       DateTime    @default(now()) @map("createdAt")
  updatedAt       DateTime    @updatedAt @map("updatedAt")

  @@index([recordId])
  @@index([userId])
  @@index([llmModel])
  @@map("likert_scores")
  @@schema("public")
}
